# Lab 3: Using the LCD Display over SPI
<!-- Please write one sentence per line, as this facilitates version control. -->
<!-- Put sample solution in comment below a question. -->

In this third lab, you will learn how to interface an LCD Display over a serial protocol (SPI), and you will draw a custom shape on the LCD display.


## Understanding the Serial Peripheral Interface (SPI) module

SPI is a serial communication interface mainly used for short-distance communication between integrated circuits (ICs).
SPI has two main variations, 4-wire and 3-wire.
The Ibex demo system supports both, and our LCD screen uses the 3-wire version.
This means the Ibex demo system receives and transmits data through the same wire (`SDA`).
As SPI is not a formal standard, there is no formal standard of it.
For this lab, we provide a simple SPI module to fit the requirements of an LCD screen.

Depending on the two parameters Clock Polarity (`CPOL`) and Clock Phase (`CPHA`), SPI communication can occur in one of four different modes.
We use default parameters of `CPOL=0` and `CPHA=1`, as required by the LCD screen.
`CPOL=0` means that when there is no transmission, the serial clock (`SCK`) is LOW.
`CPHA=1` means that data is transmitted at the positive edge of `SCK`.
The SPI host sends the transmitted bit with the serial clock to the device (LCD screen).

The SPI block in the Ibex demo system consists of two modules inside the `spi_top` wrapper module: (1) the `prim_fifo_sync` first-in first-out (FIFO) module, which enables software to write data to be transmitted without having to wait for the transmission of individual bits, and (2) the `spi_host` module, which gets the data in 8-bit bytes from the FIFO and sends it bit by bit with a generated serial clock.
Note that `spi_host` will request data from FIFO as long as it's not empty.

The clock is generated by a simple counter.
The width and the limit of the counter are determined by the parameters `ClockFrequency` and `BaudRate`, and they are currently set to generate a frequency of 12.5 MHz.
A second counter for the index of the bit in the byte that is being transmitted counts from 7 to 0, so that the most significant bit is sent first.

To fill up the FIFO and thus to send data using SPI, software needs to write to a register named `TX` at the address `0x80004000`.
Since the FIFO width is 8 bits, software needs to write to this register byte by byte.
There is also a status register named `STATUS_REG` at address `0x80004004` which has the fields for `FIFO_FULL` at bit 0 and `FIFO_EMPTY` at bit 1.

What would be different use cases for `FIFO_EMPTY` and `FIFO_FULL`?
<!-- Sample solution: FIFO_FULL can be used to prevent data loss when SPI clock was too slow compared to the system clock by waiting to write new data until FIFO is not full again. FIFO_EMPTY can be used to check if the transmission is over. -->


## Drawing on the LCD display

The LCD display is connected to the Ibex demo system via SPI.
A display driver (under `vendor/display_drivers`) implements low-level functions to write commands and data serially to the LCD display.
The commands and data formats are extracted from the data sheet of the LCD display module.
On top of these low-level functions, the driver provides functions for initializing the display, setting the orientation, clearing it, and for drawing individual pixels, vertical and horizontal lines, rectangles, characters, strings, and bitmaps.

Let's use the existing functions for drawing horizontal and vertical lines to create a new function that draws a shape composed of horizontal and vertical lines.
We suggest you implement the following function, which shall draw a cross defined by a center point, the length of one arm, and a color:
```c
Result lcd_st7735_draw_cross(St7735Context *ctx,
                             LCD_Point center,
                             uint16_t length,
                             uint32_t color);
```
Alternatively, you can implement the drawing function for a shape of your own choice.
<!-- Sample solution on the `sample-solution/lab3` branch. -->

When you are done, you can see your implementation in action on the LCD by adding a third item to the menu `items[]` array, e.g., `"3. Cross"` and then changing the reaction to a press of Button 3 to the following:
```c
case BTN3:
  lcd_st7735_clean(&lcd);
  lcd_st7735_draw_cross(&lcd, (LCD_Point){.x = 20, .y = 30}, 10, BGRColorRed);
break;
```
Recompile the program, and execute it on the FPGA.
Don't forget to check that the shape is drawn as you expect!


## Rendering a Mandelbrot set

As we can draw arbitrary bitmaps on the display, let's put Ibex to work calculating and drawing the [Mandelbrot set](https://en.wikipedia.org/wiki/Mandelbrot_set).
The LCD demo program already includes the code for that, simply select **Fractal** from the menu by pressing Button 1 on the board.


## Measuring computation cycles and displaying them

While admiring Ibex's work, we wonder how many cycles the actual computations take.
To get an answer, let's use Ibex's cycle counter.
For this, `demo_system.h` declares two functions to get the value of the cycle counter and to reset it, respectively:
```c
uint32_t get_mcycle(void);
void reset_mcycle(void);
```

Let's use these functions to count the number of cycles Ibex spends for calculations in the `fractal_mandelbrot` function:

1. Add `#include "demo_system.h"` near the top of `sw/demo/lcd_st7735/fractal.c`.
2. Append an argument `unsigned int *compute_cycles` to the `fractal_mandelbrot` function signature in `fractal.c` and `fractal.h`.
3. Initialize the cycle count to zero so it can be used for summing up; i.e., add `*compute_cycles = 0;` to the top of the body of `fractal_mandelbrot`.
4. Find the inner computation loop of the fractal.
   Put `reset_mcycle();` before it and `*compute_cycles += get_mcycle();` after it.
5. In the `fractal_test` function of `sw/demo/lcd_st7735/main.c`, declare a variable to hold the compute cycle count and pass it as last argument to `fractal_mandelbrot`.
6. After the call to `fractal_mandelbrot`, print the number of cycles on the LCD:
```c
unsigned int compute_cycles;
fractal_mandelbrot(lcd, true, &compute_cycles);
char buf[32];
snprintf(buf, 32, "cycles: %10d", compute_cycles);
lcd_st7735_puts(lcd, (LCD_Point){.x = 0, .y = 0}, buf);
timer_delay(5000);
```
7. Add `#include <stdio.h>` near the top of `sw/demo/lcd_st7735/main.c`.
8. Recompile the program and execute it on the FPGA.
<!-- Sample solution on the `sample-solution/lab3` branch. -->

How many cycles does it take Ibex to compute the fractal?
<!-- 1,186,511,608 cycles for the inner loop-->
